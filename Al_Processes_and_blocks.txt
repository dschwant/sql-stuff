CREATE PROCEDURE [dbo].[All_Processes]
WITH EXECUTE AS CALLER
AS
BEGIN
	SELECT	SPID, LAST_BATCH, CAST(DATEDIFF(N,LAST_BATCH,GETDATE()) AS VARCHAR) + ' MIN.' AGE, 
			RTRIM(STATUS) STATUS, RTRIM(HOSTNAME) HOSTNAME, RTRIM(PROGRAM_NAME) PROGRAM_NAME, 
			RTRIM(LOGINAME) LOGINAME, NAME DB, TEXT
	FROM	MASTER..SYSPROCESSES SYSP
			CROSS APPLY SYS.DM_EXEC_SQL_TEXT(SQL_HANDLE)
			JOIN SYS.DATABASES SYSD ON SYSP.DBID = SYSD.DATABASE_ID
	--WHERE	NAME = 'DB_name' 
	ORDER BY CASE WHEN RTRIM(STATUS) = 'RUNNABLE' THEN 1 WHEN RTRIM(STATUS) = 'SUSPENDED' THEN 2 ELSE 3 END, SPID;

	EXEC SP_WHO2;

	DECLARE @BLOCK_TIME DATETIME
	SELECT @BLOCK_TIME = GETDATE();

	WITH	PROCESS_LIST
			AS	(SELECT  RTRIM(CAST(@@SERVERNAME AS VARCHAR(100))) AS SERVER,
						SPID,
						BLOCKED,
						UPPER(SB.NAME) DB,
						LASTWAITTYPE,
						SP.LAST_BATCH,
						UPPER(SP.STATUS) STATUS,
						SP.HOSTNAME,
						SP.PROGRAM_NAME,
						SP.LOGINAME
				FROM    MASTER..SYSPROCESSES SP
						INNER JOIN MASTER..SYSDATABASES SB ON SP.DBID = SB.DBID),

			UNIQUE_SPID(SERVER, SPID, HOSTNAME, SPID_START, LOGIN, BLKBY) /* REMOVE DUPLICATE LINES FOR PROCESSES WHICH ARE RUNNING IN PARALELL. */
			AS	(SELECT	SERVER, SPID, HOSTNAME, 
						LAST_BATCH, 
						MAX(LOGINAME) LOGINAME, /* LOGIN ARE BLANK ON DUPLICATES */
						MAX(CASE 
							WHEN LTRIM(RTRIM(BLOCKED)) = '.' THEN NULL /* DEAL WITH THESE FIRST BECAUSE '.' CAN'T BE CAST AS AN INT */
							WHEN SPID = CAST(LTRIM(RTRIM(BLOCKED)) AS INT) THEN NULL /* NULL WHEN PROCESS IS BLOCKING ITSELF => RECURSIVE LOOP */
							ELSE CAST(LTRIM(RTRIM(BLOCKED)) AS INT) END) BLKBY
				FROM PROCESS_LIST
				WHERE SPID >= 50
				GROUP BY SERVER, SPID, HOSTNAME, LAST_BATCH),

			BLOCKED_DESC_LIST(BLOCKED, BLKBY) /* CREATE LIST WITH DESCRIPTION OF BLOCKED PROCESS AND THE BLKBY PROCESS SPID. */
			AS	(SELECT	CAST(SPID AS VARCHAR) 
						+ ' - ' + RTRIM(LOGIN) 
						+ ' - ' + RTRIM(HOSTNAME) 
						+ ' - ' + CONVERT(VARCHAR,SPID_START,120) BLOCKED,
						BLKBY 
				FROM	UNIQUE_SPID),

			BLOCKLIST(BLOCKED, BLOCKER)  /* JOIN BACK TO UNIQUE_SPID LIST TO CRETAE BLOCKER DESCRIPTION. */
			AS	(SELECT	BLOCKED_DESC_LIST.BLOCKED,
						CAST(BLOCKED_DESC_LIST.BLKBY AS VARCHAR) 
						+ ' - ' + RTRIM(DESCRIPT.LOGIN) 
						+ ' - ' + RTRIM(DESCRIPT.HOSTNAME) 
						+ ' - ' + CONVERT(VARCHAR,DESCRIPT.SPID_START,120)  BLOCKER
				FROM	BLOCKED_DESC_LIST
						LEFT OUTER JOIN UNIQUE_SPID DESCRIPT ON BLOCKED_DESC_LIST.BLKBY = DESCRIPT.SPID),

			BASE_NODES(NODE) /* UNIQUE LIST OF PROCESS DESCRIPTION THAT BLOCK SOMETHING ELSE BUT ARE NOT BLOCKED BY SOMETHING ELSE */
			AS	(SELECT	DISTINCT BLOCKLIST.BLOCKED
				FROM	BLOCKLIST JOIN BLOCKLIST BLOCKERS ON BLOCKLIST.BLOCKED = BLOCKERS.BLOCKER 
							/* THIS SEEDS ONLY THOSE THAT BLOCK SOMETHING ELSE. THIS GIVE A BASE FOR THE TREE.*/
				WHERE	LTRIM(RTRIM(BLOCKLIST.BLOCKER)) IS NULL
							/* ONLY INCLUDE THOSE THAT ARE NOT BLOCKED BY SOMETHING ELSE - WE ONLY WANT THE BASE BLOCKER, NOT INTERMEDIATE ONES. */),

			BLOCK_TREE(BLOCK_NODE, BLOCK_LEVEL, BLOCK_PATH) 
			AS (SELECT	CAST(NODE AS VARCHAR(MAX)),
						1 AS BLOCK_LEVEL, CONVERT(VARCHAR(MAX),NODE) BLOCK_PATH
				FROM	BASE_NODES

				UNION ALL

							/* RECURSE BACK TO THE BLOCKLIST TO GET ANY BLOCKED PROCESS AND PUT IT IN THE TREE PATH WITH ITS BLOCKER*/			
				SELECT	CAST(BLOCKLIST.BLOCKED AS VARCHAR(MAX)),
						BLOCK_TREE.BLOCK_LEVEL + 1 AS BLOCK_LEVEL, BLOCK_TREE.BLOCK_PATH + ' > ' + CONVERT(VARCHAR(MAX),BLOCKLIST.BLOCKED) BLOCK_PATH
				FROM	BLOCKLIST 
						JOIN BLOCK_TREE ON BLOCKLIST.BLOCKER = BLOCK_TREE.BLOCK_NODE)
			
	SELECT	@BLOCK_TIME BLOCK_TIME, REPLICATE('----',BLOCK_LEVEL - 1) + BLOCK_NODE BLOCK_TREE,
			CASE 
				WHEN BLOCK_LEVEL = 1 THEN BLOCK_NODE
				ELSE SUBSTRING(BLOCK_PATH,1,CHARINDEX('>',BLOCK_PATH)-1)
			END BLOCK_BASE,
			BLOCK_NODE, 
			BLOCK_LEVEL, 
			BLOCK_PATH, 
			@BLOCK_TIME BLOCK_TIME
	FROM BLOCK_TREE
	ORDER BY BLOCK_PATH
RETURN 0
END


